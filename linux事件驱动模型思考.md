我们知道linux的事件驱动模型经历了select，poll，epoll的几个阶段
======================================================

web服务器响应和处理web请求的过程，很多都是基于事件驱动模型的，比如nginx就是完全基于事件驱动模型的。

包含事件收集器，事件发送器，事件处理器。

事件处理器基本有三种方式实现：

+ 事件发送器每传递一个请求，目标对象创建一个新的进程，然后在这个子进程调用事件处理器来处理该请求。

+ 事件发送器传递一个请求，目标对象创建一个新的线程，调用事件处理器处理该请求。

+ 事件发送器传递一个请求，目标对象就将其放入一个待处理事件的列表，使用非阻塞I/O方式调用事件处理器处理该请求。

但是我们知道使用多进程和多线程在请求量非常大的时候，开销是非常大的，内存开销，进程（线程）调度开销。而且这个开销随着我们的请求是线性增加的。

大多数的网络服务器都是采用上面提到的第三种方式，形成“事件驱动处理库”

事件驱动模型也叫做多路I/O复用模型。

在我们的linux操作系统上，最常见的有三种模型：select模型，poll模型，epoll模型。

下面我们以此来介绍下这三种模型：

select模型
---------------------

select模型是基础的一个事件驱动模型库，linux和windows都是支持这个接口的。

使用select事件驱动库的步骤一般是：

1. 创建所关注的事件描述符集合。对于一个描述符，可以关注上面的读事件，写事件，及异常发生事件。
所以我们需要创建三类事件描述符的集合，分别用来收集读事件的描述符，写事件描述符，异常事件描述符。

2. 调用系统调用select（）函数，等待事件发生。这里我们可以设置select的超时时间。但是select的阻塞和是否设置非阻塞I/O是没有关系的。

3. 轮询所有时间的描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，select（）会返回调用结果，就进行处理。

下面就在linux操作系统上的实际运用来说明：

select函数对数据结构fd_set进行操作，这个表示一个由打开的文件描述符构成的集合。然后系统定义了一组宏来控制这些集合。

```
#include <sys/types.h>
#include <sys/time.h>

void FD_ZERO(fd_set *fdset);
void FD_CLR(int fd, fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);

int FD_ISSET(int fd, fd_set *fdset);
```

