运输层协议处在我们TCP/IP协议模型的第四层，也是OSI模型的第四层。
---------------------------

主要任务是提供端对端的进程通信。这个协议是建立在ip协议之上的，所以我们在用到这个协议的时侯前提是IP层能够正确的找到对应主机。

这里我们用到的最常用的模型是C/S模型，也就是一个主机的进程提供服务，一个本地的进程提出请求。现在我们的电脑一般服务进程和客户进程都能有。所以我们能够想到，如果是对于一个提供比较通用的服务的时候，服务的进程肯定是要用大家熟知的端口，而且不能轻易的变动，不然谁知道你使用哪个端口，如果还要另外的查询，这就有增加开销。比如linux的日期查询：

`date   端口号：13`

在linux系统中,我们把熟知端口和进程的映射表存放在 `/etc/services` 中

ICANN把我们的端口划分了三个范围段：
--------------
1. 熟知端口  0-1023   
2. 注册  1024-49151  
3. 动态  49452-65535  

对于我们的应用程序，有一个叫做socket的接口，这个接口地址有ip，和端口组成。位于运输层和应用层之间。当源点应用层需要传输报文的时候，就要把报文传输到源点运输层进行封装复用，到达终点之后就要执行分用，将报文交付给不同的进程。

在传输报文的过程，我们一般要进行三个控制：
----------------

1. 流量控制  
2. 拥塞控制  
3. 差错控制  

所谓流量控制，就是要照顾发送方，和接收方双方的分组处理能力。不能接收方收到大量的分组，来不及处理，发送方还不断的传送，这是不行的，这样会导致大量的分组丢失。导致效率低下。拥塞控制就是不能使得网络的负载大于网络的容量，也就是发送到网络上的分组不能超过该网络能够处理的分组数量。差错控制就更好理解了，就是对出了差错的分组进行处理，是重传呢还是丢弃呢？

我们的流量控制是通过两个缓冲区实现的, 差错控制是通过序号和确认实现的. 拥塞控制有开环和闭环两种策略.

总的来讲，我们的运输层只能提两种类型的服务：

+ 无连接
+ 面向连接

这里值得一提的是，在我们的网络层也是有一个无连接的概念，但是和这里的无连接完全不同。

+ 网络层的无连接，是指分组能够通过各种各样的通路到达目的地，因为ip协议是一种竭尽全力的协议。
+ 运输层的连接是指每一个分组之间存在着联系，比如TCP/SCTP协议，这里创建了一个流的环境，无连接当然就是指分组直接不存在任何联系。

下面我递进的讲一些运输层的通用协议：

1.简单无连接协议  
2. 停止等待协议  
3. 返回N协议  
4. 选择重传协议  

简单无连接协议
-------------------------------------

这个协议既没有流量控制,也没有差错控制, 我们假设他运行也是在最理想的情况下, 发送方从应用层得到一个分组之后立即发送给接收方, 接收方的运输层从网络层收到一个分组, 并交给应用层. 发送方和接收方各自为他们的应用层提供传输服务.

停止等待协议
------------------------------

这个协议我们使用了流量控制和差错控制. 发送方和接收方都使用了大小为1的滑动窗口. 发送方一次发送一个分组, 然后在发送下一个分组之前需要等待一个确认. 为了检查损坏的分组, 我们需要给每一个分组加上一个校验和, 并在分组接收方后检查它. 如果校验和不正确, 就丢弃. 当然,我们每一个分组都是要有一个计数器. 如果计数器到期了,还没得到确认, 那么就要重传分组.

在停止等待协议中, 我们使用一位字段来给分组编号, 表示序号, 这个序号是基于模2的运算.

由此, 我们可以知道, 其实停止等待协议是非常的低效的, 因为这样并不能充分的利用带宽.在组网或者有些领域, 一个任务通常会在前一个任务结束之前就已经开始了, 我们称之为流水线方式. 在我们的等待停止协议中, 并没有使用流水线的方式, 因为发送方只有在等待确认之后, 才能发送下一个分组, 这样其实是串行的一种方式. 如果我么采用了流水线方式, 那么在发送方接收到前几个分组的反馈之前还可以再发送几个分组. 这样相对于固定带宽时延积, 传送的比特数量变大了. 提高了传输效率.

返回N协议
---------------------------

我们的返回N协议, 提供了流量控制和差错控制. 假设我么标志序号使用了m位个字段, 那么就是基于模2^m的运算. 返回N协议的发送窗口最大就只能是2^m-1, 接收方的滑动窗口就是能一直是1.

为了提高传输的效率, 在发送方等待确认时候, 应当有多个分组正在传送中. 这样我们就能充分的利用信道来进行分组传输.

在这个协议中有一个叫做 确认号 的概念----askNo, 这个确认号是一个累计值, 定义了下一个希望接收的分组序号. 也就是说, 如果收到的确认号是 7, 那么6(包括6)之前的分组都是已经安全完整到达的.

我们的窗口使用三个变量来描述.

1. sf, 指向第一个待确认的.  
2. sn 指向下一个要发送的.  
3. ssize 窗口大小  

返回N协议的窗口大小必须不大于2^m-1.为什么? 

假设窗口大小2^m, 我们的确认ask分组全都丢失了, 没有到达发送方. 当计数器超期, 重启, 要求重传的时候, 发送方是从序号0 , 开始传输的, 而接收方想要的序号恰好是0 ,这个时候, 接收方就不会发现有一个循环的分组已经丢失, 不会认为这个是一个重复分组, 而会以为这个是正确的下一个循环的分组.这就是一个错误. 

如果我们的窗口大小是2^m-1, 假设m=2, 发送方窗口大小为3, 如果这个时候已经发送了3个分组, 且确认分组ask全部丢失, 没有到达发送方, 当计数器重启的时候, 会重新发送序号为0 的分组, 而接收方期待的的序号是3, 这样通过差错机制, 就能检查到并不是这个分组, 就会把序号为0的分组丢弃. 等待序号为3的分组. 这样是正确的. 

在我们的协议中, 总共只用了一个计数器. 原因是第一个等待的分组总是会最先超时. 当这个计数器超时之后, 我们就要重传所有要确认的分组.这就是返回N协议名字的由来.

返回N协议简化了接收方的处理过程. 接收方只需要跟踪一个变量, 并且不需要对失序到达的分组进行缓存, 他们只是被简单的丢弃. 如果这样丢弃了很多分组, 那么这个协议的效率是低效的. 每当一个分组丢失或损坏, 发送方就要重传所有待确认的分组. 这样还有可能会加重网络拥塞.

选择传输协议
-------------------------------------

这个协议, 我们发送方和接受方的窗口大小都是2^(m-1), 这个和返回N协议是不一样的. 这个协议和返回N协议最大的不同在于对于成功到达的分组不用重传. 我们只需要重传丢失的, 损坏的分组. 选择重传协议允许与接收窗口大小一样多的分组失序到达并保存这些分组直到连续的一组分组被交付给应用层. 

理论上, 我们的每一个分组都是需要一个计数器的, 这样当计数器超时的时候才能重传. 返回N协议是将待确认的分组当作一个整体看待, 而选择重传协议则是分别的对待每一个分组. 但是在技术实现上, 选择重传协议还是使用了一个计数器.

需要提到的是选择重传协议的确认号, 这里的确认号和返回N协议的是不一样的, 这个确认号不是累计的, 仅仅是指该序号的分组完整到达. 也就是说在选择重传协议中, 确认号定义了无差错地接收到那一个分组的序号.

同样的, 我们来解释下, 为什么选择重传协议的窗口大小必须不大于2^(m-1).

假设m=2, 那么我们的窗口大小就是2. 我们与窗口大小3的比较.

如果窗口为2, 且所有的确认分组都丢失, 当分组0的计数器超时后, 分组0被重传. 此时接收方期待的分组是2, 而不是0, 因此这个重复分组会被正确的丢失.

如果窗口为3, 所有的确认分组都丢失, 当分组0的计数器超时后, 分组0被重传, 此时接收方期待的正好包含分组0, 那么就会作为新数据接受被保存.这样是错误的.

捎带技术
---------------------

前面的四种通用协议都是单向协议. 数据分组仅在一个方向流动, 确认分组从另一个方向传来. 如果要实现双向流动, 那么就要用到一种称为捎带的技术, 来实现双向数据流动.

+ 当分组从A向B携带数据的同时, 也能够携带返回的确认, 这些确认说明了从B发来的分组的到达情况.   
+ 当分组从B向A携带数据的同时, 也能够携带返回的确认, 这些确认又说明了从A发来的分组的到达情况.  

以后在聊具体的 运输层的 TCP/UDP协议吧.
